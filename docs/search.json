[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lowell Capobianco",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "personnel.html",
    "href": "personnel.html",
    "title": "Personnel Projects",
    "section": "",
    "text": "This is a test"
  },
  {
    "objectID": "Resume.html",
    "href": "Resume.html",
    "title": "Lowell Resume",
    "section": "",
    "text": "Last updated: 2025-04-05\nDownload PDF file."
  },
  {
    "objectID": "projects/hw1/index.html",
    "href": "projects/hw1/index.html",
    "title": "HW 1",
    "section": "",
    "text": "Question 1\nProf says make a chart\n\n#|echo: false\nprint('Hello World')\n\nHello World\n\nimport matplotlib.pyplot as plt\n\nMatplotlib created a temporary cache directory at /tmp/matplotlib-_eqro3ci because the default path (/home/jovyan/.config/matplotlib) is not a writable directory; it is highly recommended to set the MPLCONFIGDIR environment variable to a writable directory, in particular to speed up the import of Matplotlib and to better support multiprocessing.\n\nimport numpy as np\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y)\nplt.title('Sine Wave')\nplt.xlabel('x')\nplt.ylabel('sin(x)')\nplt.grid()\nplt.savefig('sine_wave.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nimport sys\nprint(\"Python version:\", sys.version)\n\nPython version: 3.12.7 | packaged by conda-forge | (main, Oct  4 2024, 15:56:51) [GCC 13.3.0]\n\n\n\n4+ 7\n\n[1] 11"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "My Homework",
    "section": "",
    "text": "Hw 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHW 1\n\n\n\n\nLowell Capobianco\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "Personnel/Reddit_Scrape.html",
    "href": "Personnel/Reddit_Scrape.html",
    "title": "Begin sentiment Analysis",
    "section": "",
    "text": "import praw\nimport regex as re\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport datetime\nimport os\nimport sklearn\n\nMatplotlib created a temporary cache directory at /tmp/matplotlib-miy9g9hg because the default path (/home/jovyan/.config/matplotlib) is not a writable directory; it is highly recommended to set the MPLCONFIGDIR environment variable to a writable directory, in particular to speed up the import of Matplotlib and to better support multiprocessing.\n\n\n\nclientid = 'AfK4Ul3-lluVw6hv6sN7fA'\nclient_secret = '84Sa2URTsDJVBC3LYzI1tgEfYt9UTw'\nuser_agent = \"script:reddit-sentiment-analyzer:v1.0 (by u/capps025)\"\n\n\nreddit = praw.Reddit(\n    client_id=clientid,\n    client_secret=client_secret,\n    user_agent=user_agent\n)\n\n\nprint(reddit.read_only)\n# Output: True\n\nTrue\n\n\n\ntar_sub = 'datacenter'\n\n\nimport pandas as pd\n\nbattery_terms = ['battery', 'batteries', 'lithium', 'li-ion', 'sodium', 'lead', 'acid', 'ups']\ndata = []\nseen_comments = set()\n\nfor term in battery_terms:\n    for submission in reddit.subreddit(tar_sub).search(term, sort=\"top\", time_filter=\"all\"):\n        submission.comments.replace_more(limit=0)\n        for comment in submission.comments.list():\n            if comment.id in seen_comments:\n                continue\n            text = comment.body.lower()\n            matched_terms = [bt for bt in battery_terms if bt in text]\n            if matched_terms:\n                data.append({\n                    'comment_id': comment.id,\n                    'author': str(comment.author),\n                    'text': text,\n                    'matched_terms': matched_terms,\n                    'submission_id': submission.id,\n                    'submission_title': submission.title\n                })\n                seen_comments.add(comment.id)\n\n# Convert to DataFrame\ndf = pd.DataFrame(data)\n\n\nWe’ll use the VADER sentiment analyzer to conduct out sentiment analysis\n\nVADER will score each word in the comment\n\ngood = + 1.9\ngood!!!! = +2.3\nbad = - 2.5\nExtremely Bad = -3\nawesome = +3.1\n\nOutput from VADER will have the proprtion of posivtive and negative sentment in the text and produced a normalized value compund\nWe’ll apply the label marking it as net positive or net negative response based on the compound score\n\n\n\nfrom vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer\n\nanalyzer = SentimentIntensityAnalyzer()\n\n\n# Apply VADER to each comment's text\ndf['sentiment'] = df['text'].apply(lambda x: analyzer.polarity_scores(x))\n\n\ndf = pd.concat([df.drop('sentiment', axis=1), df['sentiment'].apply(pd.Series)], axis=1)\n\n\ndef get_label(score):\n    if score &gt;= 0.05:\n        return 'positive'\n    elif score &lt;= -0.05:\n        return 'negative'\n    else:\n        return 'neutral'\n\ndf['sentiment_label'] = df['compound'].apply(get_label)\n\n\ndf.head(3)\n\n\n\n\n\n\n\n\ncomment_id\nauthor\ntext\nmatched_terms\nsubmission_id\nsubmission_title\nneg\nneu\npos\ncompound\nsentiment_label\n\n\n\n\n0\ng0bu3y5\nghostalker47423\ndo a visual inspection, and if you see any lea...\n[batteries]\ni3jdwl\nInheriting a 30 kVA UPS with 2 strings of 24 b...\n0.084\n0.873\n0.043\n-0.4215\nnegative\n\n\n1\ng0diub1\nRedebo\ndisconnect the battery strings via the associa...\n[battery, batteries, ups]\ni3jdwl\nInheriting a 30 kVA UPS with 2 strings of 24 b...\n0.011\n0.889\n0.100\n0.8366\npositive\n\n\n2\ng0dtxqg\nletsbebuns\nthe batteries should be removed based on age. ...\n[batteries, lead, acid, ups]\ni3jdwl\nInheriting a 30 kVA UPS with 2 strings of 24 b...\n0.029\n0.971\n0.000\n-0.2617\nnegative\n\n\n\n\n\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Simulate a sample of the df for visualization\ndata = {\n    'matched_terms': df['matched_terms'],\n    'sentiment_label': df['sentiment_label']\n}\n\ndf = pd.DataFrame(data)\n\n# Explode matched_terms to allow grouping by single term\ndf_exploded = df.explode('matched_terms')\n\n# Count sentiment labels per battery type\nsentiment_counts = df_exploded.groupby(['matched_terms', 'sentiment_label']).size().unstack(fill_value=0)\n\n# Plot the sentiment distribution per battery type\nsentiment_counts.plot(kind='bar', stacked=True, figsize=(10, 6))\nplt.title('Sentiment Distribution by Battery Type')\nplt.xlabel('Battery Type')\nplt.ylabel('Number of Comments')\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.grid(axis='y')\n\nplt.show()"
  },
  {
    "objectID": "Personnel/Reddit_Sentiment/Reddit_Scrape.html",
    "href": "Personnel/Reddit_Sentiment/Reddit_Scrape.html",
    "title": "Connect to Reddit API",
    "section": "",
    "text": "import praw\nimport regex as re\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport datetime\nimport os\nimport sklearn\n\nMatplotlib created a temporary cache directory at /tmp/matplotlib-miy9g9hg because the default path (/home/jovyan/.config/matplotlib) is not a writable directory; it is highly recommended to set the MPLCONFIGDIR environment variable to a writable directory, in particular to speed up the import of Matplotlib and to better support multiprocessing.\n\n\n\nclientid = '-----------'\nclient_secret = '---------------'\nuser_agent = \"script:reddit-sentiment-analyzer:v1.0 (by u/-------)\"\n\n\nreddit = praw.Reddit(\n    client_id=clientid,\n    client_secret=client_secret,\n    user_agent=user_agent\n)\n\n\nprint(reddit.read_only)\n# Output: True\n\nTrue\n\n\n\nAssigns a Target Sub that might be useful to learn how the general sentiment around a topic\n\ntar_sub = 'datacenter'\n\n\nUsing our reddit instance look in the tar_sub for all time and sort the post by the number of upvotes in descending order\nIn each comment look through and find if any of the keywords are in it\nlower case them for easier searching\nbuild a dataframe\n\n\nimport pandas as pd\n\nbattery_terms = ['battery', 'batteries', 'lithium', 'li-ion', 'sodium', 'lead', 'acid', 'ups']\ndata = []\nseen_comments = set()\n\nfor term in battery_terms:\n    for submission in reddit.subreddit(tar_sub).search(term, sort=\"top\", time_filter=\"all\"):\n        submission.comments.replace_more(limit=0)\n        for comment in submission.comments.list():\n            if comment.id in seen_comments:\n                continue\n            text = comment.body.lower()\n            matched_terms = [bt for bt in battery_terms if bt in text]\n            if matched_terms:\n                data.append({\n                    'comment_id': comment.id,\n                    'author': str(comment.author),\n                    'text': text,\n                    'matched_terms': matched_terms,\n                    'submission_id': submission.id,\n                    'submission_title': submission.title\n                })\n                seen_comments.add(comment.id)\n\n# Convert to DataFrame\ndf = pd.DataFrame(data)\n\n\nUse the VADER sentiment analyzer to conduct out sentiment analysis\n\nVADER will score each word in the comment\n\ngood = + 1.9\ngood!!!! = +2.3\nbad = - 2.5\nExtremely Bad = -3\nawesome = +3.1\n\nOutput from VADER will have the proprtion of posivtive and negative sentment in the text and produced a normalized value compund\nWe’ll apply the label marking it as net positive or net negative response based on the compound score\n\n\n\nfrom vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer\n\nanalyzer = SentimentIntensityAnalyzer()\n\n\n# Apply VADER to each comment's text\ndf['sentiment'] = df['text'].apply(lambda x: analyzer.polarity_scores(x))\n\n\ndf = pd.concat([df.drop('sentiment', axis=1), df['sentiment'].apply(pd.Series)], axis=1)\n\n\ndef get_label(score):\n    if score &gt;= 0.05:\n        return 'positive'\n    elif score &lt;= -0.05:\n        return 'negative'\n    else:\n        return 'neutral'\n\ndf['sentiment_label'] = df['compound'].apply(get_label)\n\n\ndf.head(3)\n\n\n\n\n\n\n\n\ncomment_id\nauthor\ntext\nmatched_terms\nsubmission_id\nsubmission_title\nneg\nneu\npos\ncompound\nsentiment_label\n\n\n\n\n0\ng0bu3y5\nghostalker47423\ndo a visual inspection, and if you see any lea...\n[batteries]\ni3jdwl\nInheriting a 30 kVA UPS with 2 strings of 24 b...\n0.084\n0.873\n0.043\n-0.4215\nnegative\n\n\n1\ng0diub1\nRedebo\ndisconnect the battery strings via the associa...\n[battery, batteries, ups]\ni3jdwl\nInheriting a 30 kVA UPS with 2 strings of 24 b...\n0.011\n0.889\n0.100\n0.8366\npositive\n\n\n2\ng0dtxqg\nletsbebuns\nthe batteries should be removed based on age. ...\n[batteries, lead, acid, ups]\ni3jdwl\nInheriting a 30 kVA UPS with 2 strings of 24 b...\n0.029\n0.971\n0.000\n-0.2617\nnegative\n\n\n\n\n\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Simulate a sample of the df for visualization\ndata = {\n    'matched_terms': df['matched_terms'],\n    'sentiment_label': df['sentiment_label']\n}\n\ndf = pd.DataFrame(data)\n\n# Explode matched_terms to allow grouping by single term\ndf_exploded = df.explode('matched_terms')\n\n# Count sentiment labels per battery type\nsentiment_counts = df_exploded.groupby(['matched_terms', 'sentiment_label']).size().unstack(fill_value=0)\n\n# Plot the sentiment distribution per battery type\nsentiment_counts.plot(kind='bar', stacked=True, figsize=(10, 6))\nplt.title('Sentiment Distribution by Battery Type')\nplt.xlabel('Battery Type')\nplt.ylabel('Number of Comments')\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.grid(axis='y')\n\nplt.show()"
  }
]